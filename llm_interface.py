# Handles LLM interaction using function calling

import openai
import json
import streamlit as st

def generate_game_summary(game_data):
    """
    Generates a game summary using OpenAI's API based on the provided game data.

    Parameters:
        game_data (dict): Detailed box score data for the game.

    Returns:
        str: LLM-generated game summary.
    """
    # Set API key from Streamlit secrets
    openai.api_key = st.secrets["api_keys"]["openai"]

    # Determine the game status (Not Started, In Progress, Over)
    game_status = (
        "not started" if not game_data["Score"]["HasStarted"]
        else "in progress" if game_data["Score"]["IsInProgress"]
        else "over"
    )

    # Basic details for all games
    basic_details = f"""
    Game Summary: {game_data['Score']['AwayTeam']} vs. {game_data['Score']['HomeTeam']}
    Date & Time: {game_data['Score']['DateTime']}
    Location: {game_data['Score']['StadiumDetails']['Name']}, {game_data['Score']['StadiumDetails']['City']}, {game_data['Score']['StadiumDetails']['State']}
    Broadcast: {game_data['Score']['Channel']}
    Weather Forecast: {game_data['Score']['ForecastDescription']}, Temperature: {game_data['Score']['ForecastTempHigh']}Â°F, Wind: {game_data['Score']['ForecastWindSpeed']} mph
    """

    # Additional details based on game status
    if game_status == "not started":
        additional_details = f"""
        The {game_data['Score']['AwayTeam']} are set to face the {game_data['Score']['HomeTeam']} in this matchup. The {game_data['Score']['HomeTeam']} are currently {'favored' if game_data['Score']['PointSpread'] < 0 else 'underdogs'} by {abs(game_data['Score']['PointSpread'])} points. The over/under for this game is {game_data['Score']['OverUnder']} points.
        """
    elif game_status == "in progress":
        additional_details = f"""
        The game is currently in progress. The {game_data['Score']['AwayTeam']} have scored {game_data['Score']['AwayScore'] or '0'} points, while the {game_data['Score']['HomeTeam']} have scored {game_data['Score']['HomeScore'] or '0'} points. The game is in the {game_data['Score']['Quarter'] or 'current'} quarter with {game_data['Score']['TimeRemaining'] or 'time remaining unavailable'} on the clock. Current odds suggest a {'tight' if game_data['Score']['PointSpreadAwayTeamMoneyLine'] > -150 else 'dominant'} performance.
        """
    else:  # Game Over
        additional_details = f"""
        The game is over. The final score was {game_data['Score']['AwayTeam']} {game_data['Score']['AwayScore']} - {game_data['Score']['HomeTeam']} {game_data['Score']['HomeScore']}. The {game_data['Score']['HomeTeam']} {'won' if game_data['Score']['HomeScore'] > game_data['Score']['AwayScore'] else 'lost'} this matchup at {game_data['Score']['StadiumDetails']['Name']}.
        """

    # Combine details into a single prompt
    prompt = f"""
    {basic_details}
    {additional_details}

    Generate an engaging game summary based on the information above, emphasizing relevant and interesting details about the matchup.
    """

    # Call the OpenAI API using ChatCompletion
    try:
        response = openai.ChatCompletion.create(
            model="gpt-4",
            messages=[
                {"role": "system", "content": "You are a helpful assistant that generates engaging game summaries for sports matches."},
                {"role": "user", "content": prompt}
            ],
            temperature=0.7,
            max_tokens=500
        )
        return response.choices[0].message.content.strip()
    except Exception as e:
        st.error(f"Failed to generate game summary: {e}")
        return "Error generating game summary."
    
def generate_broadcast(game_data, user_preferences):
    """
    Generates a customized broadcast for the selected game and user preferences 
    using OpenAI's function calling feature.
    
    Parameters:
        game_data (dict): Information about the selected game.
        user_preferences (dict): User preferences, including players of interest and tone.
        
    Returns:
        str: Customized broadcast text generated by the LLM.
    """
    # Retrieve OpenAI API key from Streamlit secrets
    openai.api_key = st.secrets["api_keys"]["openai"]

    # Define the function schema for the LLM
    def create_broadcast(game_info, preferences):
        """
        Function to format the broadcast text based on game data and user preferences.
        """
        broadcast_text = f"Broadcast for {game_info['GameKey']}:\n"
        broadcast_text += f"Players of Interest: {', '.join(preferences['players'])}\n"
        broadcast_text += f"Tone: {preferences['tone']}\n"
        broadcast_text += "Game Highlights: ... (generated by LLM)"
        return broadcast_text

    function = {
        "name": "create_broadcast",
        "description": "Generates a customized broadcast for a game.",
        "parameters": {
            "type": "object",
            "properties": {
                "game_info": {
                    "type": "object",
                    "properties": {
                        "GameKey": {"type": "string"},
                        "game_data": {"type": "string"},
                    },
                    "required": ["GameKey", "game_data"],
                },
                "preferences": {
                    "type": "object",
                    "properties": {
                        "players": {
                            "type": "array",
                            "items": {"type": "string"},
                        },
                        "tone": {"type": "string"},
                    },
                    "required": ["players", "tone"],
                },
            },
            "required": ["game_info", "preferences"],
        },
    }

    # Prepare inputs for function calling
    llm_input = {
        "game_info": {
            "GameKey": game_data.get("GameKey", "Unknown Game"),
            "game_data": json.dumps(game_data),
        },
        "preferences": user_preferences,
    }

    # Send a function-calling request to OpenAI's API
    response = openai.ChatCompletion.create(
        model="gpt-3.5-turbo-0613",  # Ensure function calling is supported by the model
        messages=[
            {
                "role": "user",
                "content": "Generate a customized broadcast for the user based on the game data and preferences.",
            }
        ],
        functions=[function],
        function_call={"name": "create_broadcast"},
    )

    # Process the response
    message = response["choices"][0]["message"]

    if message.get("function_call"):
        # Extract arguments provided by the LLM for the function
        function_args = json.loads(message["function_call"]["arguments"])
        return create_broadcast(function_args["game_info"], function_args["preferences"])
    else:
        # Handle cases where the LLM doesn't call the function
        return message["content"]
