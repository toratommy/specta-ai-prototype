import os
from openai import OpenAI
import streamlit as st
import json

def generate_game_summary(game_data, temperature=0.7):
    """
    Generates a game summary using OpenAI's API based on the provided game data.

    Parameters:
        game_data (dict): Detailed box score data for the game.
        temperature (float): Temperature setting for the LLM.

    Returns:
        tuple: Basic game details (str) and LLM-generated game summary (str).
    """
    # Initialize OpenAI client
    client = OpenAI(api_key=st.secrets["api_keys"]["openai"])

    # Determine the game status (Not Started, In Progress, Over)
    game_status = (
        "not started" if not game_data["Score"]["HasStarted"]
        else "in progress" if game_data["Score"]["IsInProgress"]
        else "over"
    )

    # Basic details for display
    basic_details = f"""
**Game Summary:** {game_data['Score']['AwayTeam']} vs. {game_data['Score']['HomeTeam']}
**Date & Time:** {game_data['Score']['DateTime']}
**Location:** {game_data['Score']['StadiumDetails']['Name']}, {game_data['Score']['StadiumDetails']['City']}, {game_data['Score']['StadiumDetails']['State']}
**Broadcast:** {game_data['Score']['Channel']}
**Weather Forecast:** {game_data['Score']['ForecastDescription']}, Temperature: {game_data['Score']['ForecastTempHigh']}Â°F, Wind: {game_data['Score']['ForecastWindSpeed']} mph
    """

    # Prepare full box score JSON for the LLM
    box_score_json = json.dumps(game_data, indent=2)

    # Add game status-specific instructions
    if game_status == "not started":
        game_status_instructions = (
            "Summarize the matchup, including the teams, date, location, broadcast details, "
            "weather, and key statistics such as point spread and over/under. Highlight pregame insights."
        )
    elif game_status == "in progress":
        game_status_instructions = (
            "Summarize the current state of the game, including the score, quarter, time remaining, "
            "key plays, and notable performances. Mention any ongoing trends or momentum shifts."
        )
    else:  # Game Over
        game_status_instructions = (
            "Summarize the final outcome of the game, including the final score, notable performances, "
            "key moments, and overall game impact. Highlight any standout players or plays."
        )

    # Prompt for the LLM
    prompt = f"""
The following is a detailed JSON representation of the box score for a sports game:
{box_score_json}

Instructions:
{game_status_instructions}

Generate an engaging game summary based on the information above, emphasizing relevant and interesting details about the matchup, current game status, or final outcome as appropriate.
    """

    # Call the OpenAI API using the new client syntax
    try:
        chat_completion = client.chat.completions.create(
            model="gpt-4",
            messages=[
                {"role": "system", "content": "You are a helpful assistant that generates engaging game summaries for sports matches."},
                {"role": "user", "content": prompt}
            ],
            temperature=temperature,
            max_tokens=250,  # Limit to 250 tokens
            stop=["\n\n"]  # Stop at natural paragraph boundaries
        )

        # Extract and return the generated content
        return basic_details, chat_completion.choices[0].message.content.strip()
    except Exception as e:
        st.error(f"Failed to generate game summary: {e}")
        return basic_details, "Error generating game summary."

def generate_broadcast(game_data, user_preferences):
    """
    Generates a customized broadcast for the selected game and user preferences 
    using OpenAI's function calling feature.
    
    Parameters:
        game_data (dict): Information about the selected game.
        user_preferences (dict): User preferences, including players of interest and tone.
        
    Returns:
        str: Customized broadcast text generated by the LLM.
    """
    # Retrieve OpenAI API key from Streamlit secrets
    openai.api_key = st.secrets["api_keys"]["openai"]

    # Define the function schema for the LLM
    def create_broadcast(game_info, preferences):
        """
        Function to format the broadcast text based on game data and user preferences.
        """
        broadcast_text = f"Broadcast for {game_info['GameKey']}:\n"
        broadcast_text += f"Players of Interest: {', '.join(preferences['players'])}\n"
        broadcast_text += f"Tone: {preferences['tone']}\n"
        broadcast_text += "Game Highlights: ... (generated by LLM)"
        return broadcast_text

    function = {
        "name": "create_broadcast",
        "description": "Generates a customized broadcast for a game.",
        "parameters": {
            "type": "object",
            "properties": {
                "game_info": {
                    "type": "object",
                    "properties": {
                        "GameKey": {"type": "string"},
                        "game_data": {"type": "string"},
                    },
                    "required": ["GameKey", "game_data"],
                },
                "preferences": {
                    "type": "object",
                    "properties": {
                        "players": {
                            "type": "array",
                            "items": {"type": "string"},
                        },
                        "tone": {"type": "string"},
                    },
                    "required": ["players", "tone"],
                },
            },
            "required": ["game_info", "preferences"],
        },
    }

    # Prepare inputs for function calling
    llm_input = {
        "game_info": {
            "GameKey": game_data.get("GameKey", "Unknown Game"),
            "game_data": json.dumps(game_data),
        },
        "preferences": user_preferences,
    }

    # Send a function-calling request to OpenAI's API
    response = openai.ChatCompletion.create(
        model="gpt-3.5-turbo-0613",  # Ensure function calling is supported by the model
        messages=[
            {
                "role": "user",
                "content": "Generate a customized broadcast for the user based on the game data and preferences.",
            }
        ],
        functions=[function],
        function_call={"name": "create_broadcast"},
    )

    # Process the response
    message = response["choices"][0]["message"]

    if message.get("function_call"):
        # Extract arguments provided by the LLM for the function
        function_args = json.loads(message["function_call"]["arguments"])
        return create_broadcast(function_args["game_info"], function_args["preferences"])
    else:
        # Handle cases where the LLM doesn't call the function
        return message["content"]
